#!/usr/bin/env python3
"""Build a searchable index from block frontmatter.

Reads all blocks/**/*.md files, parses YAML frontmatter, and writes
blocks/_index.yaml with both a per-block listing and an inverted
tag_index mapping tags to block paths.

Usage:
    python scripts/build_block_index.py
    python scripts/build_block_index.py --check   # Verify all blocks have frontmatter
"""

import argparse
import sys
from datetime import date
from pathlib import Path

import yaml

REPO_ROOT = Path(__file__).resolve().parent.parent
BLOCKS_DIR = REPO_ROOT / "blocks"
INDEX_PATH = BLOCKS_DIR / "_index.yaml"


def parse_frontmatter(path: Path) -> dict | None:
    """Extract YAML frontmatter from a markdown file.

    Returns the parsed dict, or None if no frontmatter is found.
    """
    text = path.read_text()
    if not text.startswith("---"):
        return None
    end = text.find("---", 3)
    if end == -1:
        return None
    try:
        return yaml.safe_load(text[3:end])
    except yaml.YAMLError:
        return None


def build_index() -> dict:
    """Scan all block .md files and build the index structure."""
    blocks = {}
    tag_index: dict[str, list[str]] = {}

    for md_file in sorted(BLOCKS_DIR.rglob("*.md")):
        # Skip README and _index
        if md_file.name.startswith("_") or md_file.name == "README.md":
            continue

        rel = md_file.relative_to(BLOCKS_DIR).with_suffix("")
        block_key = str(rel)

        fm = parse_frontmatter(md_file)
        if fm is None:
            continue

        entry = {
            "title": fm.get("title", md_file.stem),
            "tags": fm.get("tags", []),
            "identity_positions": fm.get("identity_positions", []),
            "tracks": fm.get("tracks", []),
            "tier": fm.get("tier", "single"),
        }
        if fm.get("related_projects"):
            entry["related_projects"] = fm["related_projects"]
        if fm.get("stats"):
            entry["stats"] = fm["stats"]

        blocks[block_key] = entry

        # Build inverted tag index
        for tag in fm.get("tags", []):
            tag_index.setdefault(tag, [])
            if block_key not in tag_index[tag]:
                tag_index[tag].append(block_key)

    # Sort tag_index keys and each tag's block list
    sorted_tag_index = {}
    for tag in sorted(tag_index):
        sorted_tag_index[tag] = sorted(tag_index[tag])

    return {
        "generated": str(date.today()),
        "blocks": blocks,
        "tag_index": sorted_tag_index,
    }


def check_frontmatter() -> list[str]:
    """Return list of block files missing frontmatter."""
    missing = []
    for md_file in sorted(BLOCKS_DIR.rglob("*.md")):
        if md_file.name.startswith("_") or md_file.name == "README.md":
            continue
        if parse_frontmatter(md_file) is None:
            rel = md_file.relative_to(BLOCKS_DIR)
            missing.append(str(rel))
    return missing


def main():
    parser = argparse.ArgumentParser(description="Build block frontmatter index")
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check that all blocks have frontmatter (no write)",
    )
    args = parser.parse_args()

    if args.check:
        missing = check_frontmatter()
        if missing:
            print(f"Missing frontmatter in {len(missing)} blocks:")
            for m in missing:
                print(f"  - {m}")
            sys.exit(1)
        else:
            total = sum(
                1
                for f in BLOCKS_DIR.rglob("*.md")
                if not f.name.startswith("_") and f.name != "README.md"
            )
            print(f"All {total} blocks have valid frontmatter.")
            sys.exit(0)

    index = build_index()

    # Write with a comment header
    header = "# Auto-generated by build_block_index.py â€” do not edit manually\n"
    INDEX_PATH.write_text(
        header + yaml.dump(index, default_flow_style=False, sort_keys=False, allow_unicode=True)
    )

    block_count = len(index["blocks"])
    tag_count = len(index["tag_index"])
    print(f"Wrote {INDEX_PATH.relative_to(REPO_ROOT)}: {block_count} blocks, {tag_count} tags")


if __name__ == "__main__":
    main()
